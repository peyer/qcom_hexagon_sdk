#!/usr/bin/env python

# Python script to verify whether or not remote debugger is working properly

### Imports ###
from xml.dom.minidom import parse   # parse xml document generated by debugger
import os                           # provide output to command prompt
import subprocess                   # command prompt output and open child process
import signal                       # allow communication between child and parent processes
import sys                          # flush command prompt output
import urllib                       # handle for locally hosted pslist.xml file
from httplib import BadStatusLine


# Parse pslist.xml generated by debugger to determine whether or not debugger was initialized successfully; if not provide informative error code
def verify_debugger():
    # initialize x to 1: at EOF if x=1 then debugger initialized successfully; x!=1 unsuccessful (x value will provide error code)
    x = 1

    # open locally hosted pslist.xml file generated by debugger
    opener = urllib.FancyURLopener({})                      # provides simple handle for HTTP response codes (using no proxies and overriding environment settings)
    try:
        os.system("adb forward --list")
        f = opener.open("http://localhost:5555/pslist.xml")     # open file at specified URL location
    except  Exception, e:
        x = 55
        sys.exit(e)
    doc = parse(f)                                          # create document object from pslist.xml to allow for parsing

    # traverse doc and make sure all items have correct attributes and features for working debug_agent
    i = 0                 # i is the element index for "item" in xml doc
    run = 1               # used to ensure only first encountered error is printed and allows for early loop termination after error
    num_attributes = 5    # number of attributes per running process
    dp_min = 1            # minimum acceptable debug_port value
    dp_max = 99999        # maximum acceptable debug_port value
    if doc == None:     # if no document exists in above location then debugger not initialized
        x = 0             # update error code
        run = 0           # stop running loop
    while (i < doc.getElementsByTagName("item").length) and run:                    # while i is less than total number of "item" elements and no errors encountered
        print "\nITEM #: " + str(i)                                                 # print item number
        process = doc.getElementsByTagName("item")[i]                               # each item element is a process
        if (not num_attributes == process.getElementsByTagName("column").length) or (not run):  # if each item does not have correct total number attributes (pid, arch, processor, command, debugport) then debugger not working
            x = 2         # update error code
            run = 0       # stop running loop
        else:   # if each item has correct number of attributes then check to make sure each attribute is correct
            pid = process.getElementsByTagName("column")[0]                 # 'pid' is first attribute in target process
            if (pid.getAttribute("name") == "pid") and run:                 # if item has 'pid' attribute and no errors encountered
                print "\tpid: " + str(pid.firstChild.data)                  # print the process ID for the target process
            elif (run): # if item has no 'pid' attribute and no other errors encountered
                x = 3     # update error code
                run = 0   # stop running loop

            arch = process.getElementsByTagName("column")[1]                # 'arch' is second attribute in target process
            if (arch.getAttribute("name") == "arch") and run:               # if item has 'arch' attribute and no errors encountered
                print "\tarch: " + str(arch.firstChild.data)                # print architecture type for target process
            elif (run): # if item has no 'arch' attribute and no other errors encountered
                x = 4     # update error code
                run = 0   # stop running loop

            processor = process.getElementsByTagName("column")[2]           # 'processor' is third attribute in target process
            if (processor.getAttribute("name") == "processor") and run:     # if item has 'processor' attribute and no errors encountered
                print "\tprocessor: " + str(processor.firstChild.data)      # print processor type for target process
            elif (run): # if item has no 'processor' attribute and no other errors encountered
                x = 5     # update error code
                run = 0   # stop running loop

            command = process.getElementsByTagName("column")[3]             # 'command' is fourth attribute in target process
            if (command.getAttribute("name") == "command") and run:         # if item has 'command' attribute and no errors encountered
                print "\tprocess: " + str(command.firstChild.data)          # print command for target process
            elif (run): # if item has no 'command' attribute and no other errors encountered
                x = 6     # update error code
                run = 0   # stop running loop

            debug_port = process.getElementsByTagName("column")[4]          # debug_port is fifth attribute in target process
            if (debug_port.getAttribute("name") == "debugport") and run:    # if item has 'debug_port' attribute and no errors encountered
                print "\tdebug port: " + str(debug_port.firstChild.data)    # print debug_port value for target process
                print "\n\tNOTE: debug port changes for EVERY new attach"   # print warning message to user to make them aware that debug port value changes for every new attach
                debug_port_int = int(debug_port.firstChild.data)            # convert unicode debug_port value into integer
                if(debug_port_int < dp_min or debug_port_int > dp_max):     # check appropriate bounds on debug_port value
                    x = 8     # update error code
                    run = 0   # stop running loop
                try:
                    test = debug_port_int + 1   # test to see if debug_port value is a proper integer by adding 1
                except TypeError:               # if 1 cannot be added to debug_port_value then it is not a proper integer -> throw exception
                    x = 9     # update error code
                    run = 0   # stop running loop
                    print "Type Error"  # print appropriate error message
            elif (run):     # if item has no 'debug_port' attribute and no other errors encountered
                x = 7         # update error code
                run = 0       # stop running loop

        i = i + 1       # increment i

    # if no items exist in the document then there are no running processes -> debugger is not initialized
    if i == 0:
        x = 10    # update error code

    # Print the appropriate output depending on whether or not pslist.xml attributes were populated or not
    if x == 1:
        print "\n\n*** REMOTE DEBUGGER STATUS: remote software debugger is working properly ***\n"
    else:
        print "\n\n*** REMOTE DEBUGGER STATUS: remote software debugger is NOT initialized / NOT working properly ***\n"
        print "ERROR: "
        if (x == 0):
            print "No XML file exists on the local host for parsing"
        elif (x == 2):
            print "Process " + str(i - 1) + " has less than " + str(num_attributes) + " attributes"
        elif (x == 3):
            print "Process " + str(i - 1) + " has no pid attribute"
        elif (x == 4):
            print "Process " + str(i - 1) + " has no arch attribute"
        elif (x == 5):
            print "Process " + str(i - 1) + " has no processor attribute"
        elif (x == 6):
            print "Process " + str(i - 1) + " has no command attribute"
        elif (x == 7):
            print "Process " + str(i - 1) + " has no debug_port attribute"
        elif (x == 8):
            print "Debug port value out of acceptable range ( <1 or >99999 )"
        elif (x == 9):
            print "Debug port value not an integer data type"
        elif (x == 10):
            print "No running processes exist.\n\nIf you see 'DM_FAILED -1' then possible causes are:\n\tADSP build does not contain debug software\n\t\tOR\n\tLA and ADSP build are not compatible"
        else:
            print "Invalid error code"


# main function -> entry point of execution
def main():

    # make sure SDK environment has been set up properly
    if not os.getenv('SDK_SETUP_ENV'):
        sys.exit("\nSDK Environment not set up -> please run setup_sdk_env script from SDK's root directory.")

    if len(sys.argv) == 1:
        sys.exit("\nPlease pass the DSP as an argument. e.g: -ADSP")

    # setup device
    print '\n- Rebooting device...\n' # print message so the command prompt informs user of program state
    try:
        subprocess.check_output('adb wait-for-device reboot', shell=True) # check to make sure there is an adb recognizable connected device and ensure devices runs cleanly with no processes currently running
    except:
        sys.exit("\nadb not not functioning or no device connected to host\n")

    os.system('adb wait-for-device')
    os.system('adb root')
    os.system('adb wait-for-device')
    os.system("sleep 10") # delay parent process to allow child enough time to execute and initialize debugger and start up processes

    script = ['python', os.getenv('HEXAGON_SDK_ROOT') + '/scripts/run_remote_debug_agent.py', sys.argv[1]]
    proc = subprocess.Popen(script) # run child process and assign process to proc variable

    os.system("sleep 10") # delay parent process to allow child enough time to execute and initialize debugger and start up processes

    sys.stdout.flush() # flush outpt to command prompt display

    verify_debugger() # run verification on debugger -> obtain and print appropriate error codes
    os.kill(proc.pid, signal.SIGINT) # kill child process so it is not paused waiting for signal
    sys.stdout.flush() # flush output to command prompt display
    os.system('adb kill-server')


# get things going -> enter main
if __name__ == "__main__":
    main()

