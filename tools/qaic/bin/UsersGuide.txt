Qaic User's Guide
#################

.toc

Introduction
============

`qaic`, Qaic's Another Idl Compiler, is a command-line executable used
to implement *remote shared objects* for the aDSP Platform.  A shared
object is called *remote* if its methods can be invoked from outside
the *domain* it resides in.  A domain may be the operating system's
kernel, a user process, a mobile device, or a programming language.
In each case, the user of a remote object does not need to know *where*
the object is hosted, or what language the object is implemented in.
Instead, the user calls methods on a *stub* object generated by `qaic`.
The stub marshals the input into a shared wire format, and ships the
data off to the domain where the object is hosted.  The host domain
implements a *skel* object, also generated by `qaic`, that unmarshals
the data, and invokes the requested method on the native object.

; TODO new smark's msc is broke, comment out for now
; .msc
;    User, Stub, Wire, Skel, Object ;
;    User   => Stub   [ label = "IEx_DoWork(23)" ];
;    Stub   => Wire   [ label = "Marshal()"      ];
;    Wire   => Skel   [ label = "Unmarshal()"    ];
;    Skel   => Object [ label = "IEx_DoWork(23)" ];
;    Object => Skel   [ label = "return 42"      ];
;    Skel   => Wire   [ label = "Marshal()"      ];
;    Wire   => Stub   [ label = "Unmarshal()"    ];
;    Stub   => User   [ label = "return 42"      ];

To generate stubs and skels, `qaic` requires the interface to an object be
strictly defined.  The syntax for defining an object interface is called IDL.
`qaic` compiles IDL files into headers, stubs, and skels.  The generated header 
can be used to implement the native object, and for users to call methods on the object.  
The stub, skel and compiled into a shared object. 

The first part of this document discusses how to run and use the 
compiler, including details of the various command-line options.  The second 
part of this document covers the details of how IDL is mapped to the supported 
implementations.


Using the compiler
==================

Command-line usage
------------------

The basic command-line syntax of the tool is:

. qaic [options] file1.idl [file2.idl ... fileN.idl]

Each file specified on the command-line will be compiled by the tool according 
to the options specified.  Available options are:

* `-mdll or --map-dll`
   Generate DLL mapping

* `-o=PATH`
   Use path as the output path.  All generated files will be output to the 
   specified path.  The default is the current directory ('.').

* `--cpp` or `-p=CPP`
   Use CPP as the C preprocessor.  The value CPP must name an executable 
   program, and cannot contain any arguments.  To pass arguments to the 
   preprocessor, use `--arg-cpp` (`-pa`).

* `--arg-cpp=ARG` or `-pa=ARG`
   Pass additional argument arg to the preprocessor.  To specify arguments 
   that are themselves options, use the form `-pa=ARG` (for 
   example, `-pa=-E`).  Specifying `-pa -E` will cause the `-E` to 
   be interpreted as an option to `qaic` instead of to the preprocessor.
   Note that for [[Comment pass-through]] to work 
   properly, the preprocessor must be set to not strip comments from the 
   source.  Typically the flag to do this is `-C`, making the appropriate 
   argument to `qaic -pa=-C`.

* `--include-path=PATH` or `-I=PATH`
   Include path in the search path for included files.  May be used multiple times.

* `--indent=WIDTH` or `-i=WIDTH`
   Use an indentation width of width spaces in the generated code.

* `--warn-undefined` or `-Wu`
   Issue warning for forward-declared interfaces that are never defined.

* `--define=SYMBOL` or `-D=SYMBOL`
   Predefine macro for the preprocessor.

* `--header-only` or `-ho` 
   Only generate a header.  Stub and skeleton code is not generated if this option
   is specified.

* `--remoting-only` or `-ro` 
   Only generate stub and skeleton code.  The corresponding header is not generated
   if this option is specified.

* `--parse-only` or `-s` 
   Parse the IDL and perform semantic checking, but do not generate any 
   output.  Note that IDL files accepted without errors by the compiler 
   with `-s` are not guaranteed to work without errors when code 
   generation is enabled.

* `-v` 
   Print the version of the compiler.

* `-h` 
   Print a brief help message.

Usage examples
--------------

The examples below illustrate typical usage of the IDL compiler.

. qaic --header-only foo.idl bar.idl

The above command compiles foo.idl to the remote header file foo.h, and 
bar.idl to the remote header file bar.h.  No remoting code is generated.

. qaic foo.idl

The above command compiles foo.idl to a remote header file foo.h,
along with the following remoting code:

+------------+-----------------------------+
| File Name  | Description                 |
+============+=============================+
| foo_stub.c | C stub implementation       |
+------------+-----------------------------+
| foo_skel.c | C skeleton implementation   |
+------------+-----------------------------+

. qaic -I../bar -I../far -o out foo.idl 

The above command compiles `foo.idl`.  It uses `../bar` and `../far`
as the search path for any include files.  It uses `out` as the
result directory, and generates `out/foo.h`, `out/foo_stub.c` and
`out/foo_skel.c` files.


Using other preprocessors
-------------------------

By default, `qaic` uses an internal preprocessor.  It may be desirable to
use a different preprocessor instead.  The Microsoft `C` preprocessor can 
be used by having the compiler invoke `cl /E /C`, which is done with the 
following command-line.  Note that for this to work, `cl` must be in the `PATH`.

. qaic -p=cl -pa=/E -pa=/C file1.idl [file2.idl ... fileN.idl]

The ARM `C/C++` compiler can also be used to preprocess IDL.  Provided 
`armcc` is in the `PATH`, this can be done with the following command-line.

. qaic -p=armcc -pa=-E -pa=-C file1.idl [file2.idl ... fileN.idl]

Note that `-pa=-E` must be used instead of `-pa -E`, since in the latter 
case the `-E` is interpreted by `qaic` as being an option to `qaic`, 
not to the preprocessor.


Error messages
--------------

Any output printed by the compiler is due to either an error or a warning.  
Warnings include the text `warning:` at the beginning of the message, 
and do not abort code generation.  Any message not preceded by `warning:` 
is an error, which causes compilation to abort.  Both errors and warnings 
include a reference to the file, line, and position within that line 
(starting at 0) where the error or warning occurred.
Additional details on select errors are given in the following subsections.

Identifier 'abc' clashes with an introduced type
................................................

The [OMG IDL specification] (http://www.omg.org/cgi-bin/doc?formal/08-01-04.pdf)
includes complex scoping rules based not only 
on where types are defined, but also on where they are used.  Specifically, 
the first component (identifier) of a qualified type name is introduced into 
the scope where it is used, preventing the use of any identifier with the 
same name in that scope.  Fully-qualified names, which start with ::, are 
considered to have an empty first component, and thus result in no type 
introduction.

Consider the following example, which illustrates the basic type introduction 
rules.  For full details, see the "Names and Scoping" section of OMG IDL
Syntax & Semantics.

.idlcode
    struct Name
    {
        string first, last;
    };
 
    struct Address
    {
       string street, city, state, country;
    };
 
    module M
    {
       typedef long Age;
    };
 
    struct Person
    {
       Name   name;    // invalid IDL: 'name' clashes with 'Name'
       string address; // OK: 'Address' not introduced in this scope
       M::Age age;     // OK: only 'M', not 'Age', is introduced
    };

In the Person structure above, the use of the Name type introduces it into 
the scope of Person, which prevents the member from being called name.  The 
second member, address, is fine because the Address type is not defined 
within the scope of Person and has not been introduced.  The reference to 
`M::Age` only causes the first component, M, to be introduced into the 
scope of Person, thus the age member is also without error.

Clashes with introduced types can generally be resolved by changing the 
qualification to avoid the type introduction.  For instance, if in the 
above example the type of the name member of the Person structure were 
written ::Name, no type introduction would occur, which would avoid the 
name clash.


Comment pass-through
====================

When `qaic` identifies code comments as a [[Doxygen comments]], 
or ordinary comments.  Doxygen comments are passed through to generated 
header files.  When documenting interface methods, Doxygen comments are 
generally preferred.


Doxygen comments
----------------

When a method is documented with the Doxygen syntax, `qaic` will attempt
to translate the documentation to the target language in any output files.

Include directives and code generation
======================================

Many IDL files include other IDL files in order to make use of types and 
interfaces declared externally.  For example, when defining a Component 
Services `interface` in IDL, AEEIQI.idl needs to be included for the 
definition of `IQI`, from which all CS interfaces must derive.  However, 
one important difference between `#include` in IDL and `#include` 
in `C/C++` is that in IDL, code is not generated for modules, interfaces, 
and types included from other IDL files.  For example, consider the 
following IDL:

.idlcode
    interface foo { /* definition of foo here */ };
    interface bar : foo { /* definition of bar here */ };

If this IDL is compiled, the output will contain the appropriate code for 
both foo and bar.  However, suppose the foo definition is moved to 
foo.idl, and the IDL being compiled is changed as follows:

.idlcode
    #include "foo.idl"
    interface bar : foo { /* definition of bar here */ };

In this case, only code for bar will be generated.  Although the contents 
of foo.idl are read by the compiler, no code is generated for foo 
because it is defined in an external (included) IDL file. Instead of 
generating code for foo, the compiler will translate the `#include` 
in the IDL to a `#include` in the output, with the extension changed 
from ".idl" to ".h".

Remote header generation
------------------------

Remote headers are generated to resemble hand-written C headers.  For each `interface`
name in IDL, for each `function` name in IDL functions are generated in C in the
following format:

.ccode
   int `interface`_`function`(arg1, arg2, argN);

