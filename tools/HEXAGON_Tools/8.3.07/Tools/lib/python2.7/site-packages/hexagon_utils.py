from __future__ import print_function
import lldb
import xml.dom.minidom as dom
from xml.dom.minidom import parse
import os
import subprocess
import sys
import re
import webbrowser
if sys.version_info[0] < 3:
    import urllib
else:
    import urllib.request

def __lldb_init_module(debugger, dict):
    debugger.HandleCommand(
        'command script add -f hexagon_utils.pagetable_read pagetable')
    debugger.HandleCommand('command script add -f hexagon_utils.tlb_read tlb')
    debugger.HandleCommand('command script add -f hexagon_utils.pv8 pv8')
    debugger.HandleCommand('command script add -f hexagon_utils.pv16 pv16')
    debugger.HandleCommand('command script add -f hexagon_utils.pv32 pv32')
    debugger.HandleCommand('command script add -f hexagon_utils.target_connect target_connect')
    print("Hexagon utilities (pagetable, tlb, pv, target_connect) loaded")


def print_xml_table(root, result):
    itemlist = root.getElementsByTagName('item')
    if (not itemlist):
        print("Error: no data received", file=result)
        return
    line = ""
    for column in itemlist[0].getElementsByTagName('column'):
        line += '%10s' % column.getAttribute('name')
    print(str(line), file=result)
    for item in itemlist:
        line = ""
        for column in item.getElementsByTagName('column'):
            line += '%10s' % column.childNodes[0].nodeValue
        print(str(line), file=result)


def pagetable_read(debugger, register, result, dict):
    xml_root = page_tlb_read(debugger, "qXfer:osdata:read:pagetable:", result)
    if (xml_root is not None):
        print_xml_table(xml_root, result)
        result.SetStatus(lldb.eReturnStatusSuccessFinishResult)
    else:
        result.SetStatus(lldb.eReturnStatusFailed)


def tlb_read(debugger, register, result, dict):
    xml_root = page_tlb_read(debugger, "qXfer:osdata:read:tlbinfo:", result)
    if (xml_root is not None):
        print_xml_table(xml_root, result)
        result.SetStatus(lldb.eReturnStatusSuccessFinishResult)
    else:
        result.SetStatus(lldb.eReturnStatusFailed)


def page_tlb_read(debugger, rsp_string, result):
    l_found = False
    offset = 0
    xml_string = ""
    while (not l_found):
        debugger.GetCommandInterpreter().HandleCommand('process plugin packet send "' + \
                                       rsp_string + '{:x}'.format(offset) + ',2bb"', result)
        output = result.GetOutput()
        result.Clear()
        output_offset = output.find("response: ") + 10
        cur_line = output[output_offset:len(output) - 2]  # -2 to remove \n
        offset += len(cur_line) - 1
        if (cur_line[0] == 'l' or cur_line.find('ERROR:') >= 0 or
            cur_line.find('error:') >= 0):
            l_found = True
        xml_string += cur_line[1:]
    try:
        xml_root = dom.parseString(xml_string)
    except:
        print(xml_string)
        result.SetError("***Unable to parse xml data from simulator!")
        result.SetStatus(lldb.eReturnStatusFailed)
        return None
    return xml_root


def pv(debugger, register, result, size):
    result.Clear()
    if (not register):
        result.SetError("must specify a vector register")
        result.SetStatus(lldb.eReturnStatusFailed)
        return
    if (not register[0] in 'qQvV'):
        result.SetError("register " + register + " is not a vector register")
        result.SetStatus(lldb.eReturnStatusFailed)
        return
    res = lldb.SBCommandReturnObject()
    debugger.GetCommandInterpreter().HandleCommand('re r ' + register, res)
    error = res.GetError()
    if  error :
        result.SetError(error)
        result.SetStatus(lldb.eReturnStatusFailed)
        return
    output = res.GetOutput()
    output_offset = output.find("0x") + 2
    line = register + " ="
    temp_regval = output[output_offset:len(output) - 1]
    numbytes = size // 8
    vector_length = len(temp_regval) // 2
    for index in range(0, vector_length // numbytes):
        printme = temp_regval[0:numbytes * 2]
        line += " 0x" + printme
        temp_regval = temp_regval[numbytes * 2:]
    result.PutCString('%s' % line)


def pv8(debugger, register, result, dict):
    pv(debugger, register, result, 8)


def pv16(debugger, register, result, dict):
    pv(debugger, register, result, 16)


def pv32(debugger, register, result, dict):
    pv(debugger, register, result, 32)

def run_cmd(cmd):
    if os.system(cmd) != 0: sys.exit(2)

def print_and_get_user_pd_list():

    error = ''
    portList = []

    print("\n- Reading list of active user processes ...")
    if sys.version_info[0] < 3:
        opener = urllib.FancyURLopener({})
    else:
        opener = urllib.request.FancyURLopener({})
    try:
        f = opener.open("http://localhost:5555/pslist.xml")
    except (Exception) as e:
        error = str(e)

    if not error:
        doc = parse(f)
        if doc == None:
            error = "No XML file exists on the local host for parsing"

    if not error:
        print("\n- Please select the process to debug (if you don't see your process ensure you application is running):")
        i = 0
        while (i < doc.getElementsByTagName("item").length) and not error:
            process = doc.getElementsByTagName("item")[i]
            if (5 != process.getElementsByTagName("column").length):
                error = "column length not correct"
                break;

            command = process.getElementsByTagName("column")[3]
            if (not command.getAttribute("name") == "command"):
                error = "command not found"
                break;

            print(str(i + 1) + "\t" + str(command.firstChild.data))

            debug_port = process.getElementsByTagName("column")[4]
            if (not debug_port.getAttribute("name") == "debugport"):
                error = "failed to find debug port"
                break;

            debug_port_int = int(debug_port.firstChild.data)
            portList.append(debug_port_int)

            if (debug_port_int < 1 or debug_port_int > 99999):
                error = "debug port " + str(debug_port_int) + "out of bounds"
                break;

            i = i + 1

        if i == 0 and not error:
            error = "Unable to find any running processes"

    if error:
        error = error + "\nPlease run /scripts/verify_debugger.py to verify that the debugger is setup correctly"
        
    return error, portList

def target_connect(debugger, register, result, dict):

    if not os.getenv('SDK_SETUP_ENV'):
        result.SetError("SDK Environment not set up -> please run setup_sdk_env script from SDK's root directory")
        return

    subSyst = int(input("\n- Please select the DSP you will be debugging:\n1\tADSP\n2\tCDSP\n> "))
    if(subSyst == 1):
        dsp_name = 'ADSP'
    elif(subSyst == 2):
        dsp_name = 'CDSP'
    else:
        result.SetError("Unknown DSP, please select valid one from the list")
        return

    print('\n- Configuring the DSP to stop at user process start ...')
    run_cmd('adb wait-for-device')
    run_cmd('adb wait-for-device root')
    run_cmd('adb wait-for-device shell setprop fastrpc.process.attrs 2')
    run_cmd('adb wait-for-device shell setprop vendor.fastrpc.process.attrs 2')

    script = os.getenv('HEXAGON_SDK_ROOT') + '/scripts/run_remote_debug_agent.py'
    if not os.path.isfile(script):
        result.SetError("File not found: " + script)
        return

    try:
        if sys.version_info[0] < 3:
            with open(os.devnull, 'w') as devnull:
                procId1 = subprocess.Popen('python ' + script + ' -' + dsp_name, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE,stderr=devnull)
        else:
             procId1 = subprocess.Popen('python ' + script + ' -' + dsp_name, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.DEVNULL)
        os.system('sleep 5')
    except (Exception) as e:
        result.SetError(str(e))
        return 

    print("\n- Open a new CLI shell and run your application in adb shell.\nExample:\n\tadb shell\n\tsdm845:/ # /vendor/bin/calculator 0 1000\n")
    if sys.version_info[0] < 3:
        raw_input("- Press ENTER once your application has started\n")
    else:
        input("- Press ENTER once your application has started\n")
    error,pd_list = print_and_get_user_pd_list()
    if error:
        result.SetError(error)
        return

    itemNum = input("> ")
    if(int(itemNum) < 1 or int(itemNum) > len(pd_list)):
        result.SetError("Unknown process, please select valid one from the list")
        return
    req_port = pd_list[int(itemNum) - 1]

    run_cmd('adb forward tcp:6666 tcp:' + str(req_port))

    print("\n- Pull the user process shell module from target")
    errcode = 0
    FNULL = open(os.devnull, 'w')

    if(dsp_name == "ADSP"):
        dsp = 'adsp'
        frpcName = 'fastrpc_shell_0'
    if(dsp_name == "CDSP"):
        dsp = 'cdsp'
        frpcName = 'fastrpc_shell_3'

    filedir = os.path.dirname(__file__)
    frpcPath = filedir + '/' + frpcName

    res = lldb.SBCommandReturnObject()
    if os.path.exists(frpcPath):
        # Check the target list for the existing targets
        command = 'target list'
        debugger.GetCommandInterpreter().HandleCommand(command, res)
        error = res.GetError()
        if error:
            result.SetError(error)
            result.SetStatus(lldb.eReturnStatusFailed)
            return
        output = res.GetOutput().split('\n')
        for target in output:
            if (frpcPath.replace("/","\\")) in target:
                index = re.search('target #(\d+)', target, re.IGNORECASE).group(1)
                command = 'target delete ' + index + ' --clean'
                debugger.GetCommandInterpreter().HandleCommand(command, res)
                error = res.GetError()
                if error:
                    result.SetError(error)
                    result.SetStatus(lldb.eReturnStatusFailed)
                    return
                else:
                    break

    errcode = subprocess.call('adb pull /vendor/dsp/' + dsp + '/' + frpcName + ' ' + filedir + '/.' ,shell = True,stdout=subprocess.PIPE, stdin=subprocess.PIPE,stderr=FNULL)
    if(errcode):
        errcode = subprocess.call('adb pull /dsp/' + dsp + '/' + frpcName + ' ' + filedir + '/.' ,shell = True,stdout=subprocess.PIPE, stdin=subprocess.PIPE,stderr=FNULL)
    if(errcode):
        errcode = subprocess.call('adb pull /dsp/' + frpcName + ' ' + filedir + '/.' ,shell = True,stdout=subprocess.PIPE, stdin=subprocess.PIPE,stderr=FNULL)
    if(errcode):
        errcode = subprocess.call('adb pull /vendor/dsp/' + frpcName + ' ' + filedir + '/.' ,shell = True,stdout=subprocess.PIPE, stdin=subprocess.PIPE,stderr=FNULL)
    if(errcode):
        result.SetError("Could not find shell file: " + frpcName + " || errcode:" + str(errcode))
        result.SetStatus(lldb.eReturnStatusFailed)
        return

    command = 'target create ' + frpcPath
    debugger.GetCommandInterpreter().HandleCommand(command, res)
    error = res.GetError()
    if error:
        result.SetError(error)
        result.SetStatus(lldb.eReturnStatusFailed)
        return
    output = res.GetOutput()
    print(output)
    
    command = 'b fastrpc_uprocess_exception'
    print("- Setting breakpoint in user process execption handler\n" + command)
    debugger.GetCommandInterpreter().HandleCommand(command, res)
    error = res.GetError()
    if error:
        result.SetError(error)
        result.SetStatus(lldb.eReturnStatusFailed)
        return
    output = res.GetOutput()
    print(output)
    if sys.version_info[0] < 3:
        so_search_path = raw_input("- Please specify your shared library search path (optional).\n- If lldb cannot find your shared object then it cannot setup breakpoints in it.\n\tExample: C:/Qualcomm/Hexagon_SDK/<HEXAGON_SDK_VERSION>/examples/common/calculator/hexagon_Debug_dynamic_toolv82_v65/ship/\n> ")
    else:
        so_search_path = input("- Please specify your shared library search path (optional).\n- If lldb cannot find your shared object then it cannot setup breakpoints in it.\n\tExample: C:/Qualcomm/Hexagon_SDK/<HEXAGON_SDK_VERSION>/examples/common/calculator/hexagon_Debug_dynamic_toolv82_v65/ship/\n> ")
    if so_search_path:
        solib_path = str(so_search_path)
        for letter in solib_path:
            if letter == "\\":
                solib_path = solib_path.replace(letter,"/")
        command = 'image search-paths add . ' + solib_path
        print(command)
        debugger.GetCommandInterpreter().HandleCommand(command, res)
        error = res.GetError()
        if error:
            result.SetError(error)
            result.SetStatus(lldb.eReturnStatusFailed)
            return
        output = res.GetOutput()
        print(output)

    print("\n- Stopping at beginning of process, once stopped:\n\t- Set any additional breakpoints (module must be found in provided source paths)\n\t- Enter 'c' when ready to continue\n\n")

    command = 'gdb-remote localhost:6666'
    debugger.GetCommandInterpreter().HandleCommand(command, res)
    error = res.GetError()
    if error:
        result.SetError(error)
        result.SetStatus(lldb.eReturnStatusFailed)
        return
    output = res.GetOutput()
    print(output)
