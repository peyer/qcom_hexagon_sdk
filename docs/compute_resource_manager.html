<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
<style type="text/css">
table {
   border-collapse: collapse;
   border-width: 1px;
   border-spacing: 1px;
   border-color: transparent;
   margin: 16px 0;
   width: 100%;
}
th {
   background-color: #bbb; color: white;
}
td, th {
   border-style: solid;
   border-color: black;
   border-width: 1px;
   padding: 0 6px;
}
td p:first-child, th p:first-child {
   margin-top: 3px;
}
td p:last-child, th p:last-child {
   margin-bottom: 3px;
}

.smarkdoc {
  margin-left: 42px; margin-right: 42px;
  font-size: 13px;
  font-family: 'Lucida Grande', Geneva, Helvetica, Arial, sans-serif;
}

h1, h2, h3 { color: #3c4c6c; }
h1 {
  text-align: center;
  font-size: 200%;
/*    margin-left: -30px; */
  clear: both;
}
h2 {
  font-size: 160%;
  margin: 32px -40px 24px -42px;
  padding: 3px 24px 8px;
  border-bottom: 2px solid #5088c5;
  clear: both;
}
h3 {
  font-size: 130%;
  margin: 20px -4px 10px;
  padding: 4px;
  clear: both;
}
h4 {
  font-size: 110%;
  margin: 2em 0 1em;
}

pre {
  font-size: 90%;
  background-color: #f0f0f4; padding: 6px; border: 1px solid #d0d0ee;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

.pre {
  font-size: 90%;
  padding: 6px;
  background-color: #f0f0f4;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

code {
  font-size: 90%;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

h3 code {
  font-size: 100%;
}

p {
  margin: 0.8em 0;
}
ul, ol {
  margin: 1em 0 1em 3em; padding: 0;
}
div.indent {
  margin: 0 3em;
}

a[href] {
  text-decoration: none;
  color: #2020b0;
}
a[href]:hover {
  border-bottom: 1px dotted #2030d0;
}

/* Smark Users Guide */

.codebox {
  padding: 0 1px;  margin-right:1px;
  border:1px solid #d0d0ee;
  background-color: #f0f0f4;
  font-weight: bold;
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
}

/* ================ Smark-specific classes ================ */

.indent {
  margin: 0 3em;
}

/*
|| Floats affect text flow but not block boundaries, so graphics in a DIV
|| would overlap floats if not for "clear: both"
*/
.diagram {
  margin: 18px 0;
  clear: both;
}

/* ASCII Art */

.art {
  margin-right: auto; margin-left: auto; /* center */
  font-family: Arial, Verdana, "Lucida Console", Monaco, monospace;
  font-weight: bold;
}
.art * {
   border-color: #543;
}
.art .dline, .art .drect {
   border-style: dotted;
}
.art .rect {
   -webkit-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   -moz-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   box-shadow: 0.2em 0.2em 0.2em #875;
   background-color: #f9faf4; /* #fafff4; #f8f8ec;  */
}
.art .nofx {
   background-color: #f9faf4;
}
.art .round {
   border-radius: 0.6em;
   -webkit-border-radius: 0.6em;
   -moz-border-radius: 0.6em;
}

/* .art .line {  -webkit-box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.3); } */

/* Sequence Charts */

.msc {
   font: 11px Verdana, Monaco, "Lucida Console";
   margin-left: auto; margin-right: auto;
   background-color: white;
   /* border: 1px solid #555; */  /* Useful for non-white pages */
}

/* Table of Contents */

.tocLevel {
  margin-left: 2em;
  font-weight: normal;
}
.tocLevel .tocLevel {
  font-size: 90%; /* ...of inherited font size */
  line-height: 150%; /* ...of font size */
}
.toc > .tocLevel {
  font-weight: bold;
  margin: 0.5em 0
}
.toc {
  column-count: 2; column-gap: 2em;
  -moz-column-count: 2; -moz-column-gap: 2em;
  -webkit-column-count: 2; -webkit-column-gap: 2em;
}

/* ordinary text content is in P elements */

td p:first-child, th p:first-child {
   margin-top: 3px;
}
td p:last-child, th p:last-child {
   margin-bottom: 3px;
}
li p:only-child {
  margin-top: 0;
  margin-bottom: 0;
}

/* ================ Print ================ */

@media print {

  @page {
    margin: 0.75in 0.75in;
    size: Letter;
    @bottom {
      content: counter(page);
      vertical-align: top;
      padding-top: 1em;
    }
  }
  h1 { text-align: center;
       margin: 3in 0 20px; }
  h2 { page-break-before: always; }
  h2 { string-set: section content() }
  .toc { margin: 3em -2em }
  .toc a::after {
     font-size: 10px;
     content: leader(' . ') "  " target-counter(attr(href), page);
  }
  table { page-break-inside: avoid; }
}

/* ================  Layout  ================ */
/*
 *  +------------------------+
 *  |         #header        |
 *  +----------+-------------+
 *  | #sidebar |  #content   |
 *  |          |             |
 *  +----------+-------------+
 *
 * CSS padding, border width, and border style (!) affect the actual height
 * (and in turn layout).
 */

#header {
  position: fixed;
  top: 0px;
  height: 32px;
  left: 0px;
  width: 100%;
  padding: 10px 10px 0 0;
}
#sidebar {
  position: fixed;
  top: 42px;
  bottom: 0px;
  left: 0px;
  min-width: 180px;
  overflow: auto;
  border: 1px solid transparent;
  border-width: 0 1px 0 1px;
  padding: 0px 5px 0px 5px;
}
#content {
  position: fixed;
  top: 60px;
  left: 200px;
  bottom: 0px;
  right: 0px;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  padding: 10px 20px;
  padding-top: 0;
}

/* ================  Styles  ================ */


body {
  font-family: "Lucida Grande", Helvetica, Arial, sans-serif;
  font-size: 16px;
}

#header {
  color: #fff;
  background: #555;
  text-align: center;
  font-size: 25px;
}

#sidebar {
  color: #000;
  background: #eee;
  border-right: 1px solid #bbb;
  text-align: left;
  font-size: 12px;
  line-height: 50%;
}

#sidebar h1 {
  margin: 0 0 0 0;
  border-left: 5px solid transparent;
  text-align: left;
  font-size: 12px;
  /*text-shadow: #fff 1px 0px;*/
  line-height: 1%;
}

#sidebar h2 {
  margin: 2px 0 8px 0;
  border-left: 5px solid transparent;
  text-align: center;
  font-size: 12px;
  /*text-shadow: #fff 1px 0px;*/
  line-height: 1%;
}



#content {
  margin: 0;
  font-size: 13px;
  line-height: 160%;
}

#content h1, #content h2 {
  border-bottom: 2px solid;
  font-size: 1.8em;
  font-weight: normal;
  margin: 2.0em 0px 1.3em 0px;
  padding-bottom: 0.6em;
  text-align: left;
}

#content h3 {
  color: #242220;
  font-size: 1.4em;
  font-weight: normal;
  margin: 2em 0px 0.8em 0px;
  text-shadow: #FFFFFF 0px 1px 1px;
}
#content h4 {
  font-size: 1.2em;
  font-weight: normal;
  margin: 2em 0px 0.5em 0px;
  text-shadow: #FFFFFF 0px 1px 1px;
}

a[href] {
  color: #05c;
  text-decoration: none;
}

#sidebar a {
  /*text-shadow:  1px 1px 2px #fff, -1px -1px #ddd;*/
  line-height: 40%;
}

pre, code {
  font-family: "Courier New", "Lucida Console", "Monaco", monospace;
  font-family: "Monaco", monospace;  font-size: 90%;
  background-color: #f8f8fa;
  border: 1px solid #e4e4ee;
  -webkit-border-radius: 2px;
  -moz-border-radius: 2px;
  border-radius: 2px;
  padding: 1px 0 0 1px;
}

pre {
  padding: 2px 4px;
}

table {
   border-collapse: collapse;
   border-width: 1px;
   border-spacing: 1px;
   border-color: transparent;
   margin: 16px 0;
   width: 100%;
}
th {
   background-color: #bbb; color: white;
}
td, th {
   border-style: solid;
   border-color: black;
   border-width: 1px;
   padding: 0 6px;
}

/* Highlight currently-selected sidebar link */

#sidebar a.thisfile {
  color: #557;
}

/* indentation */

#content {
   padding-left: 60px;
}
#content h1, 
#content h2, 
#content h3, h4 {
    margin-left: -30px;
}

h3 > code {
    font-size: 80%;
}

/* ================ Smark-specific classes ================ */

.indent {
  margin: 0 3em;
}

/*
|| Floats affect text flow but not block boundaries, so graphics in a DIV 
|| would overlap floats if not for "clear: both"
*/
.diagram {
  margin: 18px 0;
  clear: both;
}

/* ASCII Art */

.art {
  margin-right: auto; margin-left: auto; /* center */
  font-family: Arial, Verdana, "Lucida Console", Monaco, monospace;
  font-weight: bold;
}
.art * {
   border-color: #543;
}
.art .dline, .art .drect {
   border-style: dotted;
}
.art .rect {
   -webkit-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   -moz-box-shadow: 0.2em 0.2em 0.3em rgba(0,0,0,0.3);
   box-shadow: 0.2em 0.2em 0.2em #875;
   background-color: #f9faf4; /* #fafff4; #f8f8ec;  */
}
.art .nofx {
   background-color: #f9faf4;
}
.art .round {
   border-radius: 0.6em;
   -webkit-border-radius: 0.6em;
   -moz-border-radius: 0.6em;
}

/* Sequence Charts */

.msc {
   font: 11px Verdana, Monaco, "Lucida Console"; 
   margin-left: auto; margin-right: auto;
   background-color: white;
   border: 1px solid #555;
}

/* Table of Contents */

.tocLevel {
  margin-left: 2em;
  font-weight: normal;
}
.tocLevel .tocLevel {
  font-size: 90%; /* ...of inherited font size */
  line-height: 150%; /* ...of font size */
}
/*
.toc > .tocLevel {
  font-weight: bold;
  margin: 0.5em 0
}
*/

.toc {
  column-count: 1; column-gap: 2em;
  -moz-column-count: 1; -moz-column-gap: 2em;
  -webkit-column-count: 1; -webkit-column-gap: 2em; 
   alternate: column-width: 235px; column-rule-width: 5px;
}


.columns {
  column-count: 2; column-gap: 2em;
  -moz-column-count: 2; -moz-column-gap: 2em;
  -webkit-column-count: 2; -webkit-column-gap: 2em; p
}

/* ordinary text content is in P elements */

td p:first-child, th p:first-child {
   margin-top: 3px;
}
td p:last-child, th p:last-child {
   margin-bottom: 3px;
}
li p:only-child {
  margin-top: 0;
  margin-bottom: 0;
}


/* ================ Print ================ */

@media print {

  #header, #content { position: static; }
  #sidebar { display: none; }

  @page {
    margin: 0.75in 0.75in;
    size: Letter;
    @bottom {
      content: counter(page);
      vertical-align: top;
      padding-top: 1em;
    }
  }
  h1 { text-align: center;
       margin: 1in 0 1in; }
  h2 { page-break-before: always; }
  h2 { string-set: section content() }
  .toc { margin: 3em 0 }
  .toc a::after {
     font-size: 10px;
     content: leader(' . ') "  " target-counter(attr(href), page);
  }
  table { page-break-inside: avoid; }
}


</style><style type="text/css">
.search { right: 20pt; position: fixed; top: 5pt }

</style><title>Compute resource manager (CDSP)</title>
</head><body>
<div class="smarkdoc"><div id="header">Hexagon SDK 3.5.4</div><div id="sidebar"><top><img src="images/sidebar_top.jpg"></top><script src="scripts/post.js" type="text/javascript"></script><form class="search" id="searchForm"><input id="searchquery" name="q" onkeydown="postFunctionKeydown(event, false)"><input id="searchButton" onclick="postFunction(false)" type="button" value="Search"></form><p>
<a href="index.html">Quick start</a>
</p><hr>
<p>
<a href="feature_matrix.html">Feature Matrix</a>
</p><hr>
<p>
<a href="hexagon_architecture.html">Hexagon Architecture</a>
</p><hr>
<p>
<a href="images/Hexagon_Document_Bundle.pdf#page=2881">Hexagon Compiler/Linker</a>
</p><hr>
<p>
<a href="hexagon_libraries.html">Hexagon Standard Libraries</a>
</p><hr>
<p>
<a href="images/80-VB419-178_QuRT_User_Guide.pdf">Hexagon RTOS</a>
</p><hr>
<p>
<a href="images/80-VB419-108_Hexagon_DSP_User_Guide.pdf">Hexagon DSP Programming</a>
</p><hr>
<p>
<a href="sitemap.html">Sitemap</a>
</p><hr>
<h3>
<a name="Platforms"></a>Platforms
</h3><p>
<a href="Platforms_HLOS.html">HLOS</a>
</p><p>
<a href="Platforms_Simulator.html">Simulator</a>
</p><p>
<a href="Platforms_Target.html">Target</a>
</p><hr>
<h3>
<a name="Environments"></a>Environments
</h3><p>
<a href="Environments_Build%20System.html">Build System</a>
</p><p>
<a href="Environments_Build%20System%20Porting.html">Build System Porting</a>
</p><p>
<a href="Environments_Hexagon%20IDE.html">Hexagon IDE</a>
</p><hr>
<h3>
<a name="ArchitectureOverview"></a>ArchitectureOverview
</h3><p>
<a href="HVX/ArchitectureOverview.html">HVX</a>
</p><hr>
<h3>
<a name="Applications"></a>Applications
</h3><p>
<a href="Audio/Applications.html">Audio</a>
</p><p>
<a href="Camera%20streaming/Applications.html">Camera streaming</a>
</p><p>
<a href="Applications_Compute%20offload.html">Compute offload</a>
</p><p>
<a href="FastCV/Applications_Computer%20Vision.html">Computer Vision</a>
</p><p>
<a href="Neural%20Networks/Applications.html">Neural Networks</a>
</p><p>
<a href="Voice/Applications.html">Voice</a>
</p><p>
<a href="Camera%20streaming/Applications_legacy.html">legacy</a>
</p><hr>
<h3>
<a name="APIs"></a>APIs
</h3><p>
<a href="APIs_Async%20Message%20Queue.html">Async Message Queue</a>
</p><p>
<a href="APIs_DSP%20Clk%20&amp;%20Rsrc%20Mgmt.html">DSP Clk &amp; Rsrc Mgmt</a>
</p><p>
<a href="APIs_Dynamic%20Loading.html">Dynamic Loading</a>
</p><p>
<a href="APIs_FastRPC.html">FastRPC</a>
</p><hr>
<h3>
<a name="Examples"></a>Examples
</h3><p>
<a href="Audio/Examples.html">Audio</a>
</p><p>
<a href="Camera%20streaming/Examples.html">Camera streaming</a>
</p><p>
<a href="Examples_Common.html">Common</a>
</p><p>
<a href="Examples_ComputeHVX.html">ComputeHVX</a>
</p><p>
<a href="Examples_GeneralOverview.html">GeneralOverview</a>
</p><p>
<a href="Neural%20Networks/Examples.html">Neural Networks</a>
</p><p>
<a href="Camera%20streaming/Examples_legacy.html">legacy</a>
</p><hr>
<h3>
<a name="Testing"></a>Testing
</h3><p>
<a href="CAPIv2/Testing_CAPIv2%20Unit%20Tests.html">CAPIv2 Unit Tests</a>
</p><p>
<a href="Testing_Eclipse%20Unit%20Tests.html">Eclipse Unit Tests</a>
</p><hr>
<h3>
<a name="Debugging"></a>Debugging
</h3><p>
<a href="Debugging_Connect%20to%20Device.html">Connect to Device</a>
</p><p>
<a href="Debugging_Exceptions.html">Exceptions</a>
</p><p>
<a href="Debugging_Message%20Logging.html">Message Logging</a>
</p><p>
<a href="Debugging_Simulator.html">Simulator</a>
</p><p>
<a href="Debugging_Target.html">Target</a>
</p><hr>
<h3>
<a name="Tools"></a>Tools
</h3><p>
<a href="Tools_Hexagon%20Tools%208.3.html">Hexagon Tools 8.3</a>
</p><p>
<a href="Tools_IDL%20Compiler.html">IDL Compiler</a>
</p><p>
<a href="Tools_On%20Target%20Profiling.html">On Target Profiling</a>
</p><p>
<a href="Tools_Scripts.html">Scripts</a>
</p><p>
<a href="Tools_Signing.html">Signing</a>
</p><p>
<a href="Tools_UserGuides.html">UserGuides</a>
</p><p>
<a href="Tools_Utilities.html">Utilities</a>
</p><hr>
<h3>
<a name="FAQ"></a>FAQ
</h3><p>
<a href="FAQ_Common.html">Common</a>
</p><p>
<a href="FAQ_Dynamic%20Loading.html">Dynamic Loading</a>
</p><p>
<a href="FAQ_FastRPC.html">FastRPC</a>
</p><p>
<a href="FAQ_Hexagon%20IDE.html">Hexagon IDE</a>
</p><hr>
<h3>
<a name="Dependencies"></a>Dependencies
</h3><p>
<a href="Dependencies_Common.html">Common</a>
</p><hr>
<h3>
<a name="Release%20Notes"></a>Release Notes
</h3><p>
<a href="Release%20Notes_Common.html">Common</a>
</p><hr>
<h3>
<a name="Support"></a>Support
</h3><p>
<a href="Support_Contact.html">Contact</a>
</p><center><img src="images/sidebar_bot.jpg"></center></div><div id="content"><a name="_top_" style="display:block;"></a><h1>
<a name="Compute%20resource%20manager%20(CDSP)"></a>Compute resource manager (CDSP)
</h1><div class="toc"><div class="tocLevel"><a href="#Supported%20chipsets">Supported chipsets</a></div><div class="tocLevel"><a href="#Overview">Overview</a></div><div class="tocLevel"><a href="#Framework%20APIs">Framework APIs</a><div class="tocLevel"><a href="#HAP_compute_res_acquire">HAP_compute_res_acquire</a></div><div class="tocLevel"><a href="#HAP_compute_res_release">HAP_compute_res_release</a></div></div><div class="tocLevel"><a href="#Attribute%20structure%20and%20helper%20APIs">Attribute structure and helper APIs</a><div class="tocLevel"><a href="#HAP_compute_res_attr_init">HAP_compute_res_attr_init</a></div><div class="tocLevel"><a href="#HAP_compute_res_attr_set_serialize">HAP_compute_res_attr_set_serialize</a></div><div class="tocLevel"><a href="#HAP_compute_res_attr_set_vtcm_param">HAP_compute_res_attr_set_vtcm_param</a></div><div class="tocLevel"><a href="#HAP_compute_res_attr_get_vtcm_ptr">HAP_compute_res_attr_get_vtcm_ptr</a></div></div><div class="tocLevel"><a href="#Usage%20Examples">Usage Examples</a><div class="tocLevel"><a href="#Example%201">Example 1</a></div><div class="tocLevel"><a href="#Example%202">Example 2</a></div><div class="tocLevel"><a href="#Example%203">Example 3</a></div></div></div><h2>
<a name="Supported%20chipsets"></a>Supported chipsets
</h2><p>
SM8250 (CDSP)
</p><h2>
<a name="Overview"></a>Overview
</h2><p>
Compute resource manager framework exposes a set of APIs to request and release compute resources and enable serialization of these requests.
</p><p>
The CDSP has a number of shared resources: Cache memory, HVX, VTCM, hardware threads, memory busses, etc. In some cases, the overhead of sharing these resources while running applications concurrently causes overall performance to deteriorate. This framework allows participating applications to run their workloads in batch (one after the other). Non-participating clients, i.e. clients not requesting serialization, can still run concurrently with a serialized batch.
</p><p>
While VTCM allocation APIs exposed under <a href="VTCM%20Manager.html">VTCM Manager</a> are still supported, the compute resource APIs include an option to allocate VTCM along with requesting serialization for best performance.
</p><h2>
<a name="Framework%20APIs"></a>Framework APIs
</h2><p>
Header file: <b>HAP_compute_res.h</b>
</p><p>
Location in SDK: <b>&lt;HEXAGON_SDK_ROOT&gt;/incs/HAP_compute_res.h</b>
</p><p>
For CDSP build (scons): env.RequirePublicApi('ADSP_SYSMON', area='performance')
</p><h3>
<a name="HAP_compute_res_acquire"></a>HAP_compute_res_acquire
</h3><table><tr><th><p>
API
</p></th><td colspan="2"><p>
unsigned int <b>HAP_compute_res_acquire</b>(<b>compute_res_attr_t*</b> res_info,
</p><div class="indent"><p>
unsigned int <b>timeout_us</b>)
</p></div></td></tr><tr><th><p>
Brief
</p></th><td colspan="2"><p>
Accepts a prepared attribute structure (res_info) and returns a <b>context id</b> for successful request with in the provided timeout (micro-seconds). Returns 0 for failures.
</p></td></tr><tr><th><p>
Return
</p></th><td colspan="2"><p>
A non-zero <b>context id</b> for success, 0 for failure.
</p></td></tr><tr><th rowspan="2"><p>
Parameters
</p></th><td><p>
<b>res_info</b>
</p></td><td><p>
<b>compute_res_attr_t*</b> : Pointer to the resource structure
</p><p>
A compute resource structure should be first initialized and appropriate parameters to be set via helper APIs prior to calling this API.
</p></td></tr><tr><td><p>
<b>timeout_us</b>
</p></td><td><p>
timeout value in micro-seconds (multiple of 100) The request will be a blocking call till this timeout if the requested resource is unavailable. The request if successful within the given timeout duration will return with a <b>context id</b>.
</p></td></tr></table><h3>
<a name="HAP_compute_res_release"></a>HAP_compute_res_release
</h3><table><tr><th><p>
API
</p></th><td colspan="2"><p>
int <b>HAP_compute_res_release</b>(unsigned int <b>context_id</b>)
</p></td></tr><tr><th><p>
Brief
</p></th><td colspan="2"><p>
Releases the resources assigned to the context bearing id: <b>context_id</b> assigned by a previous acquire call. The resources until released will remain assigned, hence user needs to call this API once the requested resource(s) is no longer needed.
</p></td></tr><tr><th><p>
Return
</p></th><td colspan="2"><p>
0 for success, non-zero for failure
</p></td></tr><tr><th><p>
Parameters
</p></th><td><p>
<b>context_id</b>
</p></td><td><p>
unsigned int
</p><p>
Context id returned by HAP_compute_res_acquire() call. All the resources attributed to this context will be released.
</p></td></tr></table><h2>
<a name="Attribute%20structure%20and%20helper%20APIs"></a>Attribute structure and helper APIs
</h2><h3>
<a name="HAP_compute_res_attr_init"></a>HAP_compute_res_attr_init
</h3><table><tr><th><p>
API
</p></th><td colspan="2"><p>
int <b>HAP_compute_res_attr_init</b>(<b>compute_res_attr_t*</b> res_info)
</p></td></tr><tr><th><p>
Brief
</p></th><td colspan="2"><p>
Initializes the attribute structure pointed to by <b>compute_res_attr_t*</b> to the defaults. Default being no resource request. User needs to call this API prior to setting any specific resource property via other helper APIs. <b>Defaults</b>: Don't participate in serialization, No VTCM request.
</p></td></tr><tr><th><p>
Return
</p></th><td colspan="2"><p>
0 for success, non-zero for failure
</p></td></tr><tr><th><p>
Parameters
</p></th><td><p>
<b>res_info</b>
</p></td><td><p>
<b>compute_res_attr_t*</b> : Pointer to the resource structure
</p><p>
The resource structure once initialized can be used to request supported resources by using appropriate helper API(s) listed below
</p></td></tr></table><h3>
<a name="HAP_compute_res_attr_set_serialize"></a>HAP_compute_res_attr_set_serialize
</h3><table><tr><th><p>
API
</p></th><td colspan="2"><p>
int <b>HAP_compute_res_attr_set_serialize</b>(<b>compute_res_attr_t*</b> res_info,
</p><div class="indent"><p>
unsigned char <b>b_serialize</b>)
</p></div></td></tr><tr><th><p>
Brief
</p></th><td colspan="2"><p>
Sets serialization option based on input (<b>b_serialize</b>) in the resource structure.
</p><p>
<b>Serialization</b>:
</p><p>
The requests with the <b>b_serialize</b> option set, will be serialized, i.e. executed one after the other. This option can be used to avoid running participating (<b>b_serialize</b> set) clients concurrently. Once a serialization request (<b>b_serialize</b> set) is accepted, the later such requests will be blocked till the successful serialization request is released. Note that, the non-participating clients (<b>b_serialize</b> not set) can still run concurrently with a serialized (<b>b_serialize</b> option set) request.
</p></td></tr><tr><th><p>
Return
</p></th><td colspan="2"><p>
0 for success, non-zero for failure
</p></td></tr><tr><th rowspan="2"><p>
Parameters
</p></th><td><p>
<b>res_info</b>
</p></td><td><p>
<b>compute_res_attr_t*</b> : Pointer to the resource structure
</p></td></tr><tr><td><p>
<b>b_serialize</b>
</p></td><td><p>
unsigned char 1 (TRUE) to participate in serialization. 0 (FALSE) otherwise. When the resource attribute structure is initialized, this property is defaulted to 0 (FALSE i.e. don't participate in serialization)
</p></td></tr></table><h3>
<a name="HAP_compute_res_attr_set_vtcm_param"></a>HAP_compute_res_attr_set_vtcm_param
</h3><table><tr><th><p>
API
</p></th><td colspan="2"><p>
int <b>HAP_compute_res_attr_set_vtcm_param</b>(<b>compute_res_attr_t*</b> res_info,
</p><div class="indent"><p>
unsigned int <b>vtcm_size</b>, unsigned char <b>b_vtcmSinglePage</b>)
</p></div></td></tr><tr><th><p>
Brief
</p></th><td colspan="2"><p>
Sets VTCM request parameters in the provided resource attribute structure. To be called by the user to request for desired VTCM chunk in the acquire call. These VTCM request attributes are reset to 0 (no VTCM request) in the resource attribute structure by HAP_compute_res_attr_init() API.
</p></td></tr><tr><th><p>
Return
</p></th><td colspan="2"><p>
0 for success, non-zero for failure
</p></td></tr><tr><th rowspan="3"><p>
Parameters
</p></th><td><p>
<b>res_info</b>
</p></td><td><p>
<b>compute_res_attr_t*</b> : Pointer to the resource structure
</p></td></tr><tr><td><p>
<b>vtcm_size</b>
</p></td><td><p>
unsigned int: Size of the request in bytes. if (<b>single_page_flag</b> == 0): The size will be aligned to 4KB. if (<b>single_page_flag</b> == 1): The size will be aligned to the closest possible page size i.e, 4KB / 16KB / 64KB / 256KB.
</p></td></tr><tr><td><p>
<b>b_vtcmSinglePage</b>
</p></td><td><p>
unsigned char: single page requirement for this allocation. 1 for single page requests, 0 otherwise. Single page requests are mandatory for scatter/gather operations as they require to be contained within a single page of memory. (The memory region used by scatter/gather instructions must reside in VTCM and cannot cross a page boundary).
</p></td></tr></table><h3>
<a name="HAP_compute_res_attr_get_vtcm_ptr"></a>HAP_compute_res_attr_get_vtcm_ptr
</h3><table><tr><th><p>
API
</p></th><td colspan="2"><p>
void* <b>HAP_compute_res_attr_get_vtcm_ptr</b>(<b>compute_res_attr_t*</b> res_info)
</p></td></tr><tr><th><p>
Brief
</p></th><td colspan="2"><p>
Retrieves VTCM memory allocation pointer post a successful acquisition from the provided resource attribute structure. This API can be called post a successful HAP_compute_res_acquire() call to retrieve the allocated VTCM pointer.
</p></td></tr><tr><th><p>
Return
</p></th><td colspan="2"><p>
void* : Pointer to the VTCM memory allocated. A value of 0 suggests no VTCM was allocated
</p></td></tr><tr><th><p>
Parameters
</p></th><td><p>
<b>res_info</b>
</p></td><td><p>
<b>compute_res_attr_t*</b> : Pointer to the resource structure
</p></td></tr></table><h2>
<a name="Usage%20Examples"></a>Usage Examples
</h2><h3>
<a name="Example%201"></a>Example 1
</h3><p>
Two processes/threads participating in serialization to allow only one execution at a time.
</p><pre><span style="color: darkgreen">/*
 * PROCESS/THREAD 1
 */</span>
compute_res_attr_t res_info;
<span style="color: blue">unsigned</span> <span style="color: blue">int</span> context_id = 0;
<span style="color: darkgreen">/*
 * Initialize the attribute structure
 */</span>
<span style="color: blue">if</span> (0 != HAP_compute_res_attr_init(&amp;res_info) )
    <span style="color: blue">return</span>;
<span style="color: darkgreen">/*
 * Set serialization option
 */</span>
<span style="color: blue">if</span> (0 != HAP_compute_res_attr_set_serialize(&amp;res_info, 1) )
    <span style="color: blue">return</span>;
<span style="color: darkgreen">/*
 * Call acquire with a timeout of 10 milli-seconds.
 */</span>
<span style="color: blue">if</span> (0 != (context_id = HAP_compute_res_acquire(&amp;res_info, 10000) ) )
{
    <span style="color: darkgreen">/*
     * Successfully requested for serialization.
     * The serialization request from PROCESS/THREAD 2 will be waiting
     * till the resource is released here.
     */</span>
    <span style="color: darkgreen">//Do my work in process/thread 1</span>
    <span style="color: darkgreen">/*
     * Done. Release the resource now using the acquired context id
     */</span>
    HAP_compute_res_release(context_id);
} <span style="color: blue">else</span> {
    <span style="color: darkgreen">/*
     * Unsuccessful allocation. Timeout would have triggered.
     * Implement a fallback or fail gracefully.
     */</span>
}

...

<span style="color: darkgreen">/*
 * PROCESS/THREAD 2
 */</span>
compute_res_attr_t res_info;
<span style="color: blue">unsigned</span> <span style="color: blue">int</span> context_id = 0;
<span style="color: darkgreen">/*
 * Initialize the attribute structure
 */</span>
<span style="color: blue">if</span> (0 != HAP_compute_res_attr_init(&amp;res_info) )
    <span style="color: blue">return</span>;
<span style="color: darkgreen">/*
 * Set serialization option
 */</span>
<span style="color: blue">if</span> (0 != HAP_compute_res_attr_set_serialize(&amp;res_info, 1) )
    <span style="color: blue">return</span>;
<span style="color: darkgreen">/*
 * Call acquire with a timeout of 10 milli-seconds
 */</span>
<span style="color: blue">if</span> (0 != (context_id = HAP_compute_res_acquire(&amp;res_info, 10000) ) )
{
    <span style="color: darkgreen">/*
     * Successfully requested for serialization.
     * The serialization request from PROCESS/THREAD 1 will be waiting
     * till the resource is released here.
     */</span>
    <span style="color: darkgreen">//Do my work in process/thread 2</span>
    <span style="color: darkgreen">/*
     * Done. Release the resource now using the acquired context id
     */</span>
    HAP_compute_res_release(context_id);
} <span style="color: blue">else</span> {
    <span style="color: darkgreen">/*
     * Unsuccessful allocation. Timeout would have triggered.
     * Implement a fallback or fail gracefully.
     */</span>
}
</pre><h3>
<a name="Example%202"></a>Example 2
</h3><p>
VTCM allocation along with serialization request from one context while the other only participates in serialization.
</p><pre><span style="color: darkgreen">/*
 * PROCESS/THREAD 1
 */</span>
compute_res_attr_t res_info;
<span style="color: blue">unsigned</span> <span style="color: blue">int</span> context_id = 0;
<span style="color: blue">void</span> *p_vtcm = NULL;
<span style="color: darkgreen">/*
 * Initialize the attribute structure
 */</span>
<span style="color: blue">if</span> (0 != HAP_compute_res_attr_init(&amp;res_info) )
    <span style="color: blue">return</span>;
<span style="color: darkgreen">/*
 * Set serialization option
 */</span>
<span style="color: blue">if</span> (0 != HAP_compute_res_attr_set_serialize(&amp;res_info, 1) )
    <span style="color: blue">return</span>;
<span style="color: darkgreen">/*
 * Set VTCM request parameters - 256KB single page
 */</span>
<span style="color: blue">if</span> (0 != HAP_compute_res_attr_set_vtcm_param(&amp;res_info,
                                             (256 * 1024),
                                             1) )
    <span style="color: blue">return</span>;
<span style="color: darkgreen">/*
 * Call acquire with a timeout of 10 milli-seconds.
 */</span>
<span style="color: blue">if</span> (0 != (context_id = HAP_compute_res_acquire(&amp;res_info, 10000) ) )
{
    <span style="color: darkgreen">/*
     * Successfully requested for serialization and acquired VTCM.
     * The serialization request from PROCESS/THREAD 2 will be waiting
     * till the resource is released here.
     */</span>
    p_vtcm = HAP_compute_res_attr_get_vtcm_ptr(&amp;res_info);
    <span style="color: blue">if</span> (0 == p_vtcm)
    {
        <span style="color: darkgreen">/*
         * VTCM allocation failed, shouldn't reach here as the acquire 
         * returned with valid context id.
         */</span>
        HAP_compute_res_release(context_id);
        <span style="color: blue">return</span>;
    }
    <span style="color: darkgreen">//Do my work in process/thread 1</span>
    <span style="color: darkgreen">/*
     * Done. Release the resource now using the acquired context id.
     * This releases our serialization request and VTCM allocation as well.
     */</span>
    HAP_compute_res_release(context_id);
    p_vtcm = NULL;
} <span style="color: blue">else</span> {
    <span style="color: darkgreen">/*
     * Unsuccessful allocation. Timeout would have triggered.
     * Implement a fallback or fail gracefully.
     */</span>
}

...

<span style="color: darkgreen">/*
 * PROCESS/THREAD 2
 */</span>
compute_res_attr_t res_info;
<span style="color: blue">unsigned</span> <span style="color: blue">int</span> context_id = 0;
<span style="color: darkgreen">/*
 * Initialize the attribute structure
 */</span>
<span style="color: blue">if</span> (0 != HAP_compute_res_attr_init(&amp;res_info) )
    <span style="color: blue">return</span>;
<span style="color: darkgreen">/*
 * Set serialization option
 */</span>
<span style="color: blue">if</span> (0 != HAP_compute_res_attr_set_serialize(&amp;res_info, 1) )
    <span style="color: blue">return</span>;
<span style="color: darkgreen">/*
 * Call acquire with a timeout of 10 milli-seconds
 */</span>
<span style="color: blue">if</span> (0 != (context_id = HAP_compute_res_acquire(&amp;res_info, 10000) ) )
{
    <span style="color: darkgreen">/*
     * Successfully requested for serialization.
     * The serialization request from PROCESS/THREAD 1 will be waiting
     * till the resource is released here even when the PROCESS/THREAD 1s
     * request for VTCM can be served.
     */</span>
    <span style="color: darkgreen">//Do my work in process/thread 2</span>
    <span style="color: darkgreen">/*
     * Done. Release the resource now using the acquired context id
     */</span>
    HAP_compute_res_release(context_id);
} <span style="color: blue">else</span> {
    <span style="color: darkgreen">/*
     * Unsuccessful allocation. Timeout would have triggered.
     * Implement a fallback or fail gracefully.
     */</span>
}
</pre><h3>
<a name="Example%203"></a>Example 3
</h3><p>
VTCM request alone without specific serialization option. As both threads allocate the entire VTCM (assumption: VTCM size = 256KB), only one gets access to VTCM while the other waits (in a way, serialized implicitly).
</p><pre><span style="color: darkgreen">/*
 * PROCESS/THREAD 1
 */</span>
compute_res_attr_t res_info;
<span style="color: blue">unsigned</span> <span style="color: blue">int</span> context_id = 0;
<span style="color: blue">void</span> *p_vtcm = NULL;
<span style="color: darkgreen">/*
 * Initialize the attribute structure
 */</span>
<span style="color: blue">if</span> (0 != HAP_compute_res_attr_init(&amp;res_info) )
    <span style="color: blue">return</span>;
<span style="color: darkgreen">/*
 * Set VTCM request parameters - 256KB single page
 */</span>
<span style="color: blue">if</span> (0 != HAP_compute_res_attr_set_vtcm_param(&amp;res_info,
                                             (256 * 1024),
                                             1) )
    <span style="color: blue">return</span>;
<span style="color: darkgreen">/*
 * Call acquire with a timeout of 10 milli-seconds.
 */</span>
<span style="color: blue">if</span> (0 != (context_id = HAP_compute_res_acquire(&amp;res_info, 10000) ) )
{
    <span style="color: darkgreen">/*
     * Successfully acquired VTCM.
     * The VTCM request from PROCESS/THREAD 2 will be waiting if enough
     * VTCM is not left to serve the request till the resource is released 
     * here.
     */</span>
    p_vtcm = HAP_compute_res_attr_get_vtcm_ptr(&amp;res_info);
    <span style="color: blue">if</span> (0 == p_vtcm)
    {
        <span style="color: darkgreen">/*
         * VTCM allocation failed, shouldn't reach here as the acquire 
         * returned with valid context id.
         */</span>
        HAP_compute_res_release(context_id);
        <span style="color: blue">return</span>;
    }
    <span style="color: darkgreen">//Do my work in process/thread 1</span>
    <span style="color: darkgreen">/*
     * Done. Release the resource now using the acquired context id.
     * This releases our VTCM allocation.
     */</span>
    HAP_compute_res_release(context_id);
    p_vtcm = NULL;
} <span style="color: blue">else</span> {
    <span style="color: darkgreen">/*
     * Unsuccessful allocation. Timeout would have triggered.
     * Implement a fallback or fail gracefully.
     */</span>
}

...

<span style="color: darkgreen">/*
 * PROCESS/THREAD 2
 */</span>
compute_res_attr_t res_info;
<span style="color: blue">unsigned</span> <span style="color: blue">int</span> context_id = 0;
<span style="color: blue">void</span> *p_vtcm = NULL;
<span style="color: darkgreen">/*
 * Initialize the attribute structure
 */</span>
<span style="color: blue">if</span> (0 != HAP_compute_res_attr_init(&amp;res_info) )
    <span style="color: blue">return</span>;
<span style="color: darkgreen">/*
 * Set VTCM request parameters - 256KB single page
 */</span>
<span style="color: blue">if</span> (0 != HAP_compute_res_attr_set_vtcm_param(&amp;res_info,
                                             (256 * 1024),
                                             1) )
    <span style="color: blue">return</span>;
<span style="color: darkgreen">/*
 * Call acquire with a timeout of 10 milli-seconds.
 */</span>
<span style="color: blue">if</span> (0 != (context_id = HAP_compute_res_acquire(&amp;res_info, 10000) ) )
{
    <span style="color: darkgreen">/*
     * Successfully acquired VTCM.
     * The VTCM request from PROCESS/THREAD 1 will be waiting if enough
     * VTCM is not left to serve the request till the resource is released 
     * here.
     */</span>
    p_vtcm = HAP_compute_res_attr_get_vtcm_ptr(&amp;res_info);
    <span style="color: blue">if</span> (0 == p_vtcm)
    {
        <span style="color: darkgreen">/*
         * VTCM allocation failed, shouldn't reach here as the acquire 
         * returned with valid context id.
         */</span>
        HAP_compute_res_release(context_id);
        <span style="color: blue">return</span>;
    }
    <span style="color: darkgreen">//Do my work in PROCESS/THREAD 2</span>
    <span style="color: darkgreen">/*
     * Done. Release the resource now using the acquired context id.
     * This releases our VTCM allocation.
     */</span>
    HAP_compute_res_release(context_id);
    p_vtcm = NULL;
} <span style="color: blue">else</span> {
    <span style="color: darkgreen">/*
     * Unsuccessful allocation. Timeout would have triggered.
     * Implement a fallback or fail gracefully.
     */</span>
}</pre><p align="center" style="display:block;padding-top: 50px;">
  Copyright &#169; 2018 Qualcomm Technologies Inc. All rights reserved.

</p><a style="display:block;padding-bottom: 700px;"></a></div></div>
</body>
</html>
